{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar isNil = require('ramda/src/isNil');\n\nvar is = require('ramda/src/is');\n\nvar has = require('ramda/src/has');\n\nvar any = require('ramda/src/any');\n\nvar equals = require('ramda/src/equals');\n\nvar keys = require('ramda/src/keys');\n\nvar pipe = require('ramda/src/pipe');\n\nvar trim = require('ramda/src/trim');\n\nvar merge = require('ramda/src/merge');\n\nvar split = require('ramda/src/split');\n\nvar reject = require('ramda/src/reject');\n\nvar map = require('ramda/src/map');\n\nvar fromPairs = require('ramda/src/fromPairs');\n\nvar anyPass = require('ramda/src/anyPass');\n\nvar isEmpty = require('ramda/src/isEmpty');\n\nvar join = require('ramda/src/join');\n\nvar mapObjIndexed = require('ramda/src/mapObjIndexed');\n\nvar pick = require('ramda/src/pick');\n\nvar replace = require('ramda/src/replace');\n\nvar toUpper = require('ramda/src/toUpper');\n\nvar zipObj = require('ramda/src/zipObj');\n\nvar curry = require('ramda/src/curry');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar isNil__default =\n/*#__PURE__*/\n_interopDefaultLegacy(isNil);\n\nvar is__default =\n/*#__PURE__*/\n_interopDefaultLegacy(is);\n\nvar has__default =\n/*#__PURE__*/\n_interopDefaultLegacy(has);\n\nvar any__default =\n/*#__PURE__*/\n_interopDefaultLegacy(any);\n\nvar equals__default =\n/*#__PURE__*/\n_interopDefaultLegacy(equals);\n\nvar keys__default =\n/*#__PURE__*/\n_interopDefaultLegacy(keys);\n\nvar pipe__default =\n/*#__PURE__*/\n_interopDefaultLegacy(pipe);\n\nvar trim__default =\n/*#__PURE__*/\n_interopDefaultLegacy(trim);\n\nvar merge__default =\n/*#__PURE__*/\n_interopDefaultLegacy(merge);\n\nvar split__default =\n/*#__PURE__*/\n_interopDefaultLegacy(split);\n\nvar reject__default =\n/*#__PURE__*/\n_interopDefaultLegacy(reject);\n\nvar map__default =\n/*#__PURE__*/\n_interopDefaultLegacy(map);\n\nvar fromPairs__default =\n/*#__PURE__*/\n_interopDefaultLegacy(fromPairs);\n\nvar anyPass__default =\n/*#__PURE__*/\n_interopDefaultLegacy(anyPass);\n\nvar isEmpty__default =\n/*#__PURE__*/\n_interopDefaultLegacy(isEmpty);\n\nvar join__default =\n/*#__PURE__*/\n_interopDefaultLegacy(join);\n\nvar mapObjIndexed__default =\n/*#__PURE__*/\n_interopDefaultLegacy(mapObjIndexed);\n\nvar pick__default =\n/*#__PURE__*/\n_interopDefaultLegacy(pick);\n\nvar replace__default =\n/*#__PURE__*/\n_interopDefaultLegacy(replace);\n\nvar toUpper__default =\n/*#__PURE__*/\n_interopDefaultLegacy(toUpper);\n\nvar zipObj__default =\n/*#__PURE__*/\n_interopDefaultLegacy(zipObj);\n\nvar curry__default =\n/*#__PURE__*/\n_interopDefaultLegacy(curry);\n\nvar DEFAULT = 'REDUXSAUCE.DEFAULT';\nvar Types =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  DEFAULT: DEFAULT\n});\n/**\n  Creates a reducer.\n  @param {string} initialState - The initial state for this reducer.\n  @param {object} handlers - Keys are action types (strings), values are reducers (functions).\n  @return {object} A reducer object.\n */\n\nvar cr = function cr(initialState, handlers) {\n  // initial state is required\n  if (initialState === undefined) {\n    throw new Error('initial state is required');\n  } // handlers must be an object\n\n\n  if (isNil__default['default'](handlers) || !is__default['default'](Object, handlers)) {\n    throw new Error('handlers must be an object');\n  } // handlers cannot have an undefined key\n\n\n  if (any__default['default'](equals__default['default']('undefined'))(keys__default['default'](handlers))) {\n    throw new Error('handlers cannot have an undefined key');\n  } // create the reducer function\n\n\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; // wrong actions, just return state\n\n    if (isNil__default['default'](action)) return state;\n    if (!has__default['default']('type', action)) return state; // look for the handler\n\n    var handler = handlers[action.type] || handlers[DEFAULT]; // no handler no cry\n\n    if (isNil__default['default'](handler)) return state; // execute the handler\n\n    return handler(state, action);\n  };\n};\n\nvar isNilOrEmpty = anyPass__default['default']([isNil__default['default'], isEmpty__default['default']]);\nvar defaultOptions$1 = {\n  prefix: ''\n};\n\nvar ct = function ct(types) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (isNilOrEmpty(types)) throw new Error('valid types are required');\n\n  var _merge = merge__default['default'](defaultOptions$1, options),\n      prefix = _merge.prefix;\n\n  return pipe__default['default'](trim__default['default'], split__default['default'](/\\s/), map__default['default'](trim__default['default']), reject__default['default'](isNilOrEmpty), map__default['default'](function (x) {\n    return [x, prefix + x];\n  }), fromPairs__default['default'])(types);\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defaultOptions = {\n  prefix: ''\n}; // matches each word in a camelCaseString (except the first)\n// consecutive capitals are treated as one word\n\nvar RX_CAPS = /(?!^)([A-Z][a-z0-9]+|[A-Z][A-Z0-9]*(?=[A-Z]|\\b))/g; // converts a camelCaseWord into a SCREAMING_SNAKE_CASE word\n\nvar camelToScreamingSnake = pipe__default['default'](replace__default['default'](RX_CAPS, '_$1'), toUpper__default['default']); // build Action Types out of an object\n\nvar convertToTypes = function convertToTypes(config, options) {\n  var opts = merge__default['default'](defaultOptions, options);\n  return pipe__default['default'](keys__default['default'], // just the keys\n  map__default['default'](camelToScreamingSnake), // CONVERT_THEM\n  join__default['default'](' '), // space separated\n  function (types) {\n    return ct(types, opts);\n  } // make them into Redux Types\n  )(config);\n}; // an action creator with additional properties\n\n\nvar createActionCreator = function createActionCreator(name, extraPropNames, options) {\n  var _merge = merge__default['default'](defaultOptions, options),\n      prefix = _merge.prefix; // types are upcase and snakey\n\n\n  var type = \"\".concat(prefix).concat(camelToScreamingSnake(name)); // do we need extra props for this?\n\n  var noKeys = isNil__default['default'](extraPropNames) || isEmpty__default['default'](extraPropNames); // a type-only action creator\n\n  if (noKeys) return function () {\n    return {\n      type: type\n    };\n  }; // an action creator with type + properties\n  // \"properties\" is defined as an array of prop names\n\n  if (is__default['default'](Array, extraPropNames)) {\n    return function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      var extraProps = zipObj__default['default'](extraPropNames, values);\n      return _objectSpread2({\n        type: type\n      }, extraProps);\n    };\n  } // an action creator with type + properties\n  // \"properties\" is defined as an object of {prop name: default value}\n\n\n  if (is__default['default'](Object, extraPropNames)) {\n    var defaultProps = extraPropNames;\n    return function () {\n      var valueObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var providedProps = pick__default['default'](Object.keys(defaultProps), valueObject);\n      return _objectSpread2(_objectSpread2({\n        type: type\n      }, defaultProps), providedProps);\n    };\n  }\n\n  throw new Error('action props must be a null/array/object/function');\n}; // build Action Creators out of an object\n\n\nvar convertToCreators = function convertToCreators(config, options) {\n  return mapObjIndexed__default['default'](function (num, key, value) {\n    if (typeof value[key] === 'function') {\n      // the user brought their own action creator\n      return value[key];\n    } else {\n      // lets make an action creator for them!\n      return createActionCreator(key, value[key], options);\n    }\n  })(config);\n};\n\nvar ca = function ca(config, options) {\n  if (isNil__default['default'](config)) {\n    throw new Error('an object is required to setup types and creators');\n  }\n\n  if (isEmpty__default['default'](config)) {\n    throw new Error('empty objects are not supported');\n  }\n\n  return {\n    Types: convertToTypes(config, options),\n    Creators: convertToCreators(config, options)\n  };\n};\n/**\n * Allows your reducers to be reset.\n *\n * @param {string} typeToReset - The action type to listen for.\n * @param {function} originalReducer - The reducer to wrap.\n */\n\n\nfunction resettableReducer$1(typeToReset, originalReducer) {\n  // a valid type is required\n  if (!is__default['default'](String, typeToReset) || typeToReset === '') {\n    throw new Error('A valid reset type is required.');\n  } // an original reducer is required\n\n\n  if (typeof originalReducer !== 'function') {\n    throw new Error('A reducer is required.');\n  } // run it through first to get what the default state should be\n\n\n  var resetState = originalReducer(undefined, {}); // create our own reducer that wraps the original one and hijacks the reset\n\n  function reducer() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resetState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (action && action.type === typeToReset) {\n      return resetState;\n    } else {\n      return originalReducer(state, action);\n    }\n  }\n\n  return reducer;\n}\n\nvar rr = curry__default['default'](resettableReducer$1);\nvar createReducer = cr;\nvar createTypes = ct;\nvar createActions = ca;\nvar resettableReducer = rr;\nexports.Types = Types;\nexports.createActions = createActions;\nexports.createReducer = createReducer;\nexports.createTypes = createTypes;\nexports.resettableReducer = resettableReducer;","map":null,"metadata":{},"sourceType":"script"}